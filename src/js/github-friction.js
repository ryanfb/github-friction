// Generated by CoffeeScript 1.6.3
(function() {
  var build_github_friction, check_friction, delete_cookie, expires_in_to_date, friction_checks, get_auth_code, get_cookie, github_friction_oauth, github_oauth_url, set_access_token_cookie, set_cookie, set_cookie_expiration_callback,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  github_friction_oauth = {
    client_id: 'f066b4cdf3404200113c',
    redirect_uri: 'http://localhost:4000/'
  };

  github_oauth_url = function() {
    return "https://github.com/login/oauth/authorize?" + ($.param(github_friction_oauth));
  };

  friction_checks = {
    readme: {
      path: '/',
      regex: /README/,
      name: 'README',
      info: 'Every project begins with a README.',
      url: 'http://bit.ly/1dqUYQF',
      critical: true
    },
    contributing: {
      path: '/',
      regex: /CONTRIBUTING/,
      name: 'CONTRIBUTING guide',
      info: 'Add a guide for potential contributors.',
      url: 'http://git.io/z-TiGg',
      critical: true
    },
    license: {
      path: '/',
      regex: /LICENSE/,
      name: 'LICENSE',
      info: 'Add a license to protect yourself and your users.',
      url: 'http://choosealicense.com/',
      critical: true
    },
    testscript: {
      path: '/script',
      regex: /test/,
      name: 'Test script',
      info: 'Make it easy to run the test suite regardless of project type.',
      url: 'http://bit.ly/JZjVL6',
      critical: false
    },
    bootstrap: {
      path: '/script',
      regex: /bootstrap/,
      name: 'Bootstrap script',
      info: 'A bootstrap script makes setup a snap.',
      url: 'http://bit.ly/JZjVL6',
      critical: false
    }
  };

  get_auth_code = function() {
    var m, params, query_string, regex;
    query_string = location.search.substring(1);
    params = {};
    if (query_string.length > 0) {
      regex = /([^&=]+)=([^&]*)/g;
      while (m = regex.exec(query_string)) {
        params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
      }
    }
    history.replaceState(null, '', window.location.href.replace("" + location.search, ''));
    return params;
  };

  expires_in_to_date = function(expires_in) {
    var cookie_expires;
    cookie_expires = new Date;
    cookie_expires.setTime(cookie_expires.getTime() + expires_in * 1000);
    return cookie_expires;
  };

  set_cookie = function(key, value, expires_in) {
    var cookie;
    cookie = "" + key + "=" + value + "; ";
    cookie += "expires=" + (expires_in_to_date(expires_in).toUTCString()) + "; ";
    cookie += "path=" + (window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1));
    return document.cookie = cookie;
  };

  delete_cookie = function(key) {
    return set_cookie(key, null, -1);
  };

  get_cookie = function(key) {
    var cookie_fragment, _i, _len, _ref;
    key += "=";
    _ref = document.cookie.split(';');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cookie_fragment = _ref[_i];
      cookie_fragment = cookie_fragment.replace(/^\s+/, '');
      if (cookie_fragment.indexOf(key) === 0) {
        return cookie_fragment.substring(key.length, cookie_fragment.length);
      }
    }
    return null;
  };

  set_access_token_cookie = function(params, callback) {
    console.log('set_access_token_cookie');
    console.log(params);
    if (params['state'] != null) {
      console.log("Replacing hash with state: " + params['state']);
      history.replaceState(null, '', window.location.href.replace("" + location.hash, "#" + params['state']));
    }
    if (params['code'] != null) {
      console.log('got code');
      return $.ajax("https://github-friction-gatekeeper.herokuapp.com/authenticate/" + params['code'], {
        type: 'GET',
        dataType: 'json',
        crossDomain: 'true',
        error: function(jqXHR, textStatus, errorThrown) {
          return console.log("Access Token Exchange Error: " + textStatus);
        },
        success: function(data) {
          console.log('gatekeeper success');
          console.log(data);
          set_cookie('access_token', data.token, 31536000);
          set_cookie('access_token_expires_at', expires_in_to_date(params['expires_in']).getTime(), params['expires_in']);
          if (callback != null) {
            return callback();
          }
        }
      });
    } else {
      if (callback != null) {
        return callback();
      }
    }
  };

  set_cookie_expiration_callback = function() {
    var expires_in;
    if (get_cookie('access_token_expires_at')) {
      expires_in = get_cookie('access_token_expires_at') - (new Date()).getTime();
      console.log(expires_in);
      return setTimeout((function() {
        console.log("cookie expired");
        return window.location.reload();
      }), expires_in);
    }
  };

  check_friction = function(repo, branch) {
    console.log("check_friction for " + branch);
    console.log(repo);
    return repo.getTree(branch, function(err, tree) {
      var script_directory;
      console.log(tree);
      (tree.filter(function(git_object) {
        return git_object.type === 'blob';
      })).map(function(blob) {
        var friction_check, name, _results;
        _results = [];
        for (name in friction_checks) {
          friction_check = friction_checks[name];
          if ((friction_check.path === '/') && friction_check.regex.test(blob.path)) {
            _results.push(console.log("" + blob.path + " hit for " + name));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      script_directory = (tree.filter(function(git_object) {
        return (git_object.type === 'tree') && (git_object.path === 'script');
      }))[0];
      if (script_directory) {
        return repo.getTree(script_directory.sha, function(err, script_tree) {
          console.log("script");
          console.log(script_tree);
          return (script_tree.filter(function(git_object) {
            return git_object.type === 'blob';
          })).map(function(blob) {
            var friction_check, name, _results;
            _results = [];
            for (name in friction_checks) {
              friction_check = friction_checks[name];
              if ((friction_check.path === '/script') && friction_check.regex.test(blob.path)) {
                _results.push(console.log("" + blob.path + " hit for " + name));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
        });
      } else {
        return console.log('no script directory');
      }
    });
  };

  build_github_friction = function() {
    var github, repo_list, user;
    console.log('build');
    if (get_cookie('access_token')) {
      console.log('got access token');
      repo_list = $('<ul>').attr('id', 'repo_list');
      $(document.body).append(repo_list);
      github = new Github({
        token: get_cookie('access_token'),
        auth: 'oauth'
      });
      user = github.getUser();
      return user.repos(function(err, repos) {
        return repos.map(function(repo) {
          var _this = this;
          console.log(repo);
          $('#repo_list').append($('<li>').text(repo.name));
          return github.getRepo(repo.owner.login, repo.name).listBranches(function(err, branches) {
            console.log(repo.name);
            console.log(branches);
            if (__indexOf.call(branches, 'master') >= 0) {
              return check_friction(github.getRepo(repo.owner.login, repo.name), 'master');
            } else {
              return check_friction(github.getRepo(repo.owner.login, repo.name), branches[0]);
            }
          });
        });
      });
    } else {
      console.log('redirecting to oauth');
      return window.location = github_oauth_url();
    }
  };

  $(document).ready(function() {
    console.log('ready');
    return set_access_token_cookie(get_auth_code(), build_github_friction);
  });

}).call(this);
