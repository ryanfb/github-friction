// Generated by CoffeeScript 1.6.3
(function() {
  var build_github_friction, delete_cookie, expires_in_to_date, get_auth_code, get_cookie, github_friction_oauth, github_oauth_url, set_access_token_cookie, set_cookie, set_cookie_expiration_callback;

  github_friction_oauth = {
    client_id: 'f066b4cdf3404200113c',
    redirect_uri: 'http://localhost:4000/'
  };

  github_oauth_url = function() {
    return "https://github.com/login/oauth/authorize?" + ($.param(github_friction_oauth));
  };

  get_auth_code = function() {
    var m, params, query_string, regex;
    query_string = location.search.substring(1);
    params = {};
    if (query_string.length > 0) {
      regex = /([^&=]+)=([^&]*)/g;
      while (m = regex.exec(query_string)) {
        params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
      }
    }
    history.replaceState(null, '', window.location.href.replace("" + location.search, ''));
    return params;
  };

  expires_in_to_date = function(expires_in) {
    var cookie_expires;
    cookie_expires = new Date;
    cookie_expires.setTime(cookie_expires.getTime() + expires_in * 1000);
    return cookie_expires;
  };

  set_cookie = function(key, value, expires_in) {
    var cookie;
    cookie = "" + key + "=" + value + "; ";
    cookie += "expires=" + (expires_in_to_date(expires_in).toUTCString()) + "; ";
    cookie += "path=" + (window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1));
    return document.cookie = cookie;
  };

  delete_cookie = function(key) {
    return set_cookie(key, null, -1);
  };

  get_cookie = function(key) {
    var cookie_fragment, _i, _len, _ref;
    key += "=";
    _ref = document.cookie.split(';');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cookie_fragment = _ref[_i];
      cookie_fragment = cookie_fragment.replace(/^\s+/, '');
      if (cookie_fragment.indexOf(key) === 0) {
        return cookie_fragment.substring(key.length, cookie_fragment.length);
      }
    }
    return null;
  };

  set_access_token_cookie = function(params, callback) {
    console.log('set_access_token_cookie');
    console.log(params);
    if (params['state'] != null) {
      console.log("Replacing hash with state: " + params['state']);
      history.replaceState(null, '', window.location.href.replace("" + location.hash, "#" + params['state']));
    }
    if (params['code'] != null) {
      console.log('got code');
      return $.ajax("https://github-friction-gatekeeper.herokuapp.com/authenticate/" + params['code'], {
        type: 'GET',
        dataType: 'json',
        crossDomain: 'true',
        error: function(jqXHR, textStatus, errorThrown) {
          return console.log("Access Token Exchange Error: " + textStatus);
        },
        success: function(data) {
          console.log('gatekeeper success');
          console.log(data);
          set_cookie('access_token', data.token, 31536000);
          set_cookie('access_token_expires_at', expires_in_to_date(params['expires_in']).getTime(), params['expires_in']);
          if (callback != null) {
            return callback();
          }
        }
      });
    } else {
      if (callback != null) {
        return callback();
      }
    }
  };

  set_cookie_expiration_callback = function() {
    var expires_in;
    if (get_cookie('access_token_expires_at')) {
      expires_in = get_cookie('access_token_expires_at') - (new Date()).getTime();
      console.log(expires_in);
      return setTimeout((function() {
        console.log("cookie expired");
        return window.location.reload();
      }), expires_in);
    }
  };

  build_github_friction = function() {
    console.log('build');
    if (get_cookie('access_token')) {
      return console.log('got access token');
    } else {
      console.log('redirecting to oauth');
      return window.location = github_oauth_url();
    }
  };

  $(document).ready(function() {
    console.log('ready');
    return set_access_token_cookie(get_auth_code(), build_github_friction);
  });

}).call(this);
