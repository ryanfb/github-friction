// Generated by CoffeeScript 1.6.3
(function() {
  var build_github_friction, check_friction, delete_cookie, expires_in_to_date, friction_checks, get_auth_code, get_cookie, github_friction_oauth, github_oauth_url, mark_done, mark_missing, set_access_token_cookie, set_cookie, set_cookie_expiration_callback,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  github_friction_oauth = {
    client_id: 'f066b4cdf3404200113c',
    redirect_uri: 'http://localhost:4000/'
  };

  github_oauth_url = function() {
    return "https://github.com/login/oauth/authorize?" + ($.param(github_friction_oauth));
  };

  friction_checks = {
    readme: {
      path: '/',
      regex: /^README/,
      name: 'README',
      info: 'Every project begins with a README.',
      url: 'http://bit.ly/1dqUYQF',
      critical: true
    },
    contributing: {
      path: '/',
      regex: /^CONTRIBUTING/,
      name: 'CONTRIBUTING guide',
      info: 'Add a guide for potential contributors.',
      url: 'http://git.io/z-TiGg',
      critical: true
    },
    license: {
      path: '/',
      regex: /^LICENSE/,
      name: 'LICENSE',
      info: 'Add a license to protect yourself and your users.',
      url: 'http://choosealicense.com/',
      critical: true
    },
    testscript: {
      path: '/script',
      regex: /^test/,
      name: 'Test script',
      info: 'Make it easy to run the test suite regardless of project type.',
      url: 'http://bit.ly/JZjVL6',
      critical: false
    },
    bootstrap: {
      path: '/script',
      regex: /^bootstrap/,
      name: 'Bootstrap script',
      info: 'A bootstrap script makes setup a snap.',
      url: 'http://bit.ly/JZjVL6',
      critical: false
    }
  };

  get_auth_code = function() {
    var m, params, query_string, regex;
    query_string = location.search.substring(1);
    params = {};
    if (query_string.length > 0) {
      regex = /([^&=]+)=([^&]*)/g;
      while (m = regex.exec(query_string)) {
        params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
      }
    }
    history.replaceState(null, '', window.location.href.replace("" + location.search, ''));
    return params;
  };

  expires_in_to_date = function(expires_in) {
    var cookie_expires;
    cookie_expires = new Date;
    cookie_expires.setTime(cookie_expires.getTime() + expires_in * 1000);
    return cookie_expires;
  };

  set_cookie = function(key, value, expires_in) {
    var cookie;
    cookie = "" + key + "=" + value + "; ";
    cookie += "expires=" + (expires_in_to_date(expires_in).toUTCString()) + "; ";
    cookie += "path=" + (window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1));
    return document.cookie = cookie;
  };

  delete_cookie = function(key) {
    return set_cookie(key, null, -1);
  };

  get_cookie = function(key) {
    var cookie_fragment, _i, _len, _ref;
    key += "=";
    _ref = document.cookie.split(';');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cookie_fragment = _ref[_i];
      cookie_fragment = cookie_fragment.replace(/^\s+/, '');
      if (cookie_fragment.indexOf(key) === 0) {
        return cookie_fragment.substring(key.length, cookie_fragment.length);
      }
    }
    return null;
  };

  set_access_token_cookie = function(params, callback) {
    console.log('set_access_token_cookie');
    console.log(params);
    if (params['state'] != null) {
      console.log("Replacing hash with state: " + params['state']);
      history.replaceState(null, '', window.location.href.replace("" + location.hash, "#" + params['state']));
    }
    if (params['code'] != null) {
      console.log('got code');
      return $.ajax("https://github-friction-gatekeeper.herokuapp.com/authenticate/" + params['code'], {
        type: 'GET',
        dataType: 'json',
        crossDomain: 'true',
        error: function(jqXHR, textStatus, errorThrown) {
          return console.log("Access Token Exchange Error: " + textStatus);
        },
        success: function(data) {
          console.log('gatekeeper success');
          console.log(data);
          set_cookie('access_token', data.token, 31536000);
          set_cookie('access_token_expires_at', expires_in_to_date(params['expires_in']).getTime(), params['expires_in']);
          if (callback != null) {
            return callback();
          }
        }
      });
    } else {
      if (callback != null) {
        return callback();
      }
    }
  };

  set_cookie_expiration_callback = function() {
    var expires_in;
    if (get_cookie('access_token_expires_at')) {
      expires_in = get_cookie('access_token_expires_at') - (new Date()).getTime();
      console.log(expires_in);
      return setTimeout((function() {
        console.log("cookie expired");
        return window.location.reload();
      }), expires_in);
    }
  };

  mark_missing = function(repo_id) {
    var data_cell, friction_check, link, name, _results;
    _results = [];
    for (name in friction_checks) {
      friction_check = friction_checks[name];
      data_cell = $("#" + repo_id + " > ." + name);
      if (data_cell.hasClass('info')) {
        data_cell.removeClass('info');
        if (friction_check.critical) {
          data_cell.addClass('danger');
        } else {
          data_cell.addClass('warning');
        }
        link = $('<a>').attr('href', friction_check.url);
        link.attr('title', friction_check.info);
        link.attr('target', '_blank');
        link.text(friction_check.name);
        data_cell.text('');
        _results.push(data_cell.append(link));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  mark_done = function(repo_id, name, file_name) {
    var branch, data_cell, link, repo_url;
    data_cell = $("#" + repo_id + " > ." + name);
    data_cell.removeClass('info').addClass('success');
    link = $('<a>');
    repo_url = $("#" + repo_id + " > .name > a").attr('href');
    branch = $("#" + repo_id + " > .branch").text();
    link.attr('href', "" + repo_url + "/blob/" + branch + "/" + file_name);
    link.attr('target', '_blank');
    link.text(data_cell.text());
    data_cell.text('');
    return data_cell.append(link);
  };

  check_friction = function(repo_id, repo, branch) {
    console.log("check_friction for " + branch + " of " + repo_id);
    return repo.getTree(branch, function(err, tree) {
      var script_directory;
      console.log(tree);
      (tree.filter(function(git_object) {
        return git_object.type === 'blob';
      })).map(function(blob) {
        var friction_check, name, _results;
        _results = [];
        for (name in friction_checks) {
          friction_check = friction_checks[name];
          if ((friction_check.path === '/') && friction_check.regex.test(blob.path)) {
            console.log("" + blob.path + " hit for " + name);
            console.log(blob);
            _results.push(mark_done(repo_id, name, blob.path));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      script_directory = (tree.filter(function(git_object) {
        return (git_object.type === 'tree') && (git_object.path === 'script');
      }))[0];
      if (script_directory) {
        return repo.getTree(script_directory.sha, function(err, script_tree) {
          console.log("script");
          console.log(script_tree);
          (script_tree.filter(function(git_object) {
            return git_object.type === 'blob';
          })).map(function(blob) {
            var friction_check, name, _results;
            _results = [];
            for (name in friction_checks) {
              friction_check = friction_checks[name];
              if ((friction_check.path === '/script') && friction_check.regex.test(blob.path)) {
                console.log("" + blob.path + " hit for " + name);
                _results.push(mark_done(repo_id, name, "script/" + blob.path));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
          return mark_missing(repo_id);
        });
      } else {
        console.log("no script directory for " + repo_id);
        return mark_missing(repo_id);
      }
    });
  };

  build_github_friction = function() {
    var container, github, jumbotron, repo_list, user;
    console.log('build');
    if (get_cookie('access_token')) {
      console.log('got access token');
      repo_list = $('<table>').attr('id', 'repo_list').attr('class', 'table table-bordered');
      container = $('<div>').attr('class', 'container');
      container.append($('<br>'));
      jumbotron = $('<div>');
      jumbotron.append($('<h1>').text('GitHub Friction'));
      jumbotron.append($('<p>').attr('class', 'lead').text('Check for common sources of contributor friction across your GitHub repositories.'));
      container.append(jumbotron);
      container.append(repo_list);
      $(document.body).append(container);
      github = new Github({
        token: get_cookie('access_token'),
        auth: 'oauth'
      });
      user = github.getUser();
      return user.repos(function(err, repos) {
        return repos.map(function(repo) {
          var friction_check, name, repo_div, repo_link, repo_row,
            _this = this;
          console.log(repo);
          repo_row = $('<tr>').attr('id', repo.id);
          repo_link = $('<a>').attr('href', repo.html_url).text(repo.full_name).attr('target', '_blank');
          repo_div = $('<td>').addClass('name').append(repo_link);
          repo_row.append(repo_div);
          repo_row.append($('<td>').attr('class', 'active text-center').text('master').addClass('branch'));
          for (name in friction_checks) {
            friction_check = friction_checks[name];
            repo_row.append($('<td>').attr('class', 'info text-center').text(friction_check.name).addClass(name));
          }
          $('#repo_list').append(repo_row);
          return github.getRepo(repo.owner.login, repo.name).listBranches(function(err, branches) {
            console.log(repo.name);
            console.log(branches);
            if (__indexOf.call(branches, 'master') >= 0) {
              return check_friction(repo.id, github.getRepo(repo.owner.login, repo.name), 'master');
            } else {
              $("#" + repo.id + " > .branch").text(branches[0]);
              return check_friction(repo.id, github.getRepo(repo.owner.login, repo.name), branches[0]);
            }
          });
        });
      });
    } else {
      console.log('redirecting to oauth');
      return window.location = github_oauth_url();
    }
  };

  $(document).ready(function() {
    console.log('ready');
    return set_access_token_cookie(get_auth_code(), build_github_friction);
  });

}).call(this);
